import { useSheetStore } from "@/stores/sheetStore";
import api, { callApi } from "../api";
import type { CreateSheetRequest, DeleteDto, SheetDto, SheetListItemDto } from "@/types/dtos";
import type { Sheet } from "@/types/types";
import { toRef } from "vue";

/**
 * Fetch all sheets in condensed format (without content and capo)
 * @param options.force - Force refetch even if data is already loaded
 */
export async function fetchAllSheets(options: { force?: boolean } = {}): Promise<void> {
    const sheetStore = useSheetStore();
    // Skip if already loaded unless force is true
    if (!options.force && sheetStore.sheetsList.length > 0) return;

    await callApi<SheetListItemDto[]>({
        loadingRef: toRef(sheetStore, 'loading'),
        errorRef: toRef(sheetStore, 'error'),
        apiCall: () => api.get('/sheets'),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                sheetStore.error = 'Request content is empty';
                return;
            }

            sheetStore.sheetsList = data.payload.map((sheet) => ({
                id: sheet.id,
                title: sheet.title,
                artist: sheet.artist ?? null,
                tags: sheet.tags ?? [],
            }));
        },
    });
}

/**
 * Fetch a single sheet with full details (includes content and capo)
 * @param id - The sheet ID to fetch
 * @param options.force - Force refetch even if already cached
 */
export async function fetchSheet(id: string, options: { force?: boolean } = {}): Promise<void> {
    const sheetStore = useSheetStore();

    // Skip if already cached unless force is true
    if (!options.force && sheetStore.detailedSheets[id]) return;

    await callApi<SheetDto>({
        loadingRef: toRef(sheetStore, 'loading'),
        errorRef: toRef(sheetStore, 'error'),
        apiCall: () => api.get('/sheets'),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                sheetStore.error = 'Request payload is empty';
                return;
            }

            sheetStore.detailedSheets[id] = {
                id: data.payload.id,
                title: data.payload.title,
                artist: data.payload.artist ?? null,
                tags: data.payload.tags ?? [],
                capo: data.payload.capo,
                sourceURL: data.payload.source_url,
                content: data.payload.content,
            };
        },
    });
}

/**
 * Create a new sheet and add it to the detailed cache
 * @param sheet - Sheet data without ID (generated by backend)
 */
export async function createSheet(sheet: Omit<Sheet, 'id'>): Promise<void> {
    const sheetStore = useSheetStore();

    const payload: CreateSheetRequest = {
        title: sheet.title,
        content: sheet.content,
        capo: sheet.capo,
        source_url: sheet.sourceURL,
        artist_id: sheet.artist?.id,
        tag_ids: sheet.tags?.map((tag) => tag.id),
    };

    await callApi<SheetDto>({
        loadingRef: toRef(sheetStore, 'loading'),
        errorRef: toRef(sheetStore, 'error'),
        apiCall: () => api.post('/sheets', payload),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                sheetStore.error = 'Request payload is empty';
                return;
            }

            sheetStore.detailedSheets[data.payload.id] = {
                id: data.payload.id,
                title: data.payload.title,
                artist: data.payload.artist,
                tags: data.payload.tags,
                capo: data.payload.capo,
                sourceURL: data.payload.source_url,
                content: data.payload.content,
            };

            // Add to sheetsList as well
            sheetStore.sheetsList.push({
                id: data.payload.id,
                title: data.payload.title,
                artist: data.payload.artist,
                tags: data.payload.tags,
            });
        },
    });
}

/**
 * Update a sheet with only the changed fields
 * @param id - The sheet ID to update
 * @param fieldsToUpdate - Partial sheet data with fields to update
 */
export async function updateSheet(id: string, fieldsToUpdate: Partial<Omit<Sheet, 'id'>>): Promise<void> {
    const sheetStore = useSheetStore();

    const currentSheet = sheetStore.detailedSheets[id];

    const payload: {
        title?: string;
        content?: string;
        capo?: number;
        source_url?: string;
        artist_id?: number;
        tag_ids?: number[];
    } = {};

    // Compare primitive fields
    if (
        fieldsToUpdate.title !== undefined &&
        fieldsToUpdate.title !== currentSheet?.title
    ) {
        payload.title = fieldsToUpdate.title;
    }
    if (
        fieldsToUpdate.content !== undefined &&
        fieldsToUpdate.content !== currentSheet?.content
    ) {
        payload.content = fieldsToUpdate.content;
    }
    if (fieldsToUpdate.capo !== undefined && fieldsToUpdate.capo !== currentSheet?.capo) {
        payload.capo = fieldsToUpdate.capo;
    }
    if (
        fieldsToUpdate.sourceURL !== undefined &&
        fieldsToUpdate.sourceURL !== currentSheet?.sourceURL
    ) {
        payload.source_url = fieldsToUpdate.sourceURL;
    }

    // Compare complex fields using JSON serialization
    if (
        fieldsToUpdate.artist !== undefined &&
        JSON.stringify(fieldsToUpdate.artist) !== JSON.stringify(currentSheet?.artist)
    ) {
        payload.artist_id = fieldsToUpdate.artist?.id;
    }
    if (
        fieldsToUpdate.tags !== undefined &&
        JSON.stringify(fieldsToUpdate.tags) !== JSON.stringify(currentSheet?.tags)
    ) {
        payload.tag_ids = fieldsToUpdate.tags?.map((tag) => tag.id);
    }

    // Don't send request if nothing changed
    if (Object.keys(payload).length === 0) {
        return;
    }

    await callApi<SheetDto>({
        loadingRef: toRef(sheetStore, 'loading'),
        errorRef: toRef(sheetStore, 'error'),
        apiCall: () => api.put(`/sheets/${id}`, payload),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                sheetStore.error = 'Request payload is empty';
                return;
            }

            sheetStore.detailedSheets[data.payload.id] = {
                id: data.payload.id,
                title: data.payload.title,
                artist: data.payload.artist,
                tags: data.payload.tags,
                capo: data.payload.capo,
                sourceURL: data.payload.source_url,
                content: data.payload.content,
            };

            // Add to sheetsList as well
            sheetStore.sheetsList.push({
                id: data.payload.id,
                title: data.payload.title,
                artist: data.payload.artist,
                tags: data.payload.tags,
            });
        },
    });
}

/**
 * Delete a sheet and remove it from the cache
 * @param id - The sheet ID to delete
 */
export async function deleteSheet(id: string): Promise<void> {
    const sheetStore = useSheetStore();

    await callApi<DeleteDto>({
        loadingRef: toRef(sheetStore, 'loading'),
        errorRef: toRef(sheetStore, 'error'),
        apiCall: () => api.delete(`/sheets/${id}`),
        onSuccess: () => {
            delete sheetStore.detailedSheets[id];

            // Also remove from sheetsList
            const index = sheetStore.sheetsList.findIndex((sheet) => sheet.id === Number(id));
            if (index !== -1) {
                sheetStore.sheetsList.splice(index, 1);
            }
        },
    });
}