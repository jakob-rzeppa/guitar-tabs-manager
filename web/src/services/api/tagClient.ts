import { useTagsStore } from "@/stores/tagsStore";
import api, { useApiInStore } from "../api";
import type { CreateTagRequest, TagDto, UpdateTagRequest } from "@/types/dtos";
import type { Tag } from "@/types/types";
import { useSheetsStore } from "@/stores/sheetsStore";


/**
 * Fetch all tags
 * @param options.force - Force refetch even if data is already loaded
 */
export async function fetchAllTags(options: { force?: boolean } = {}): Promise<void> {
    const tagsStore = useTagsStore();
    // Skip if already loaded unless force is true
    if (!options.force && tagsStore.tags.length > 0) return;

    await useApiInStore<TagDto[]>({
        store: tagsStore,
        apiCall: () => api.get('/tags'),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                tagsStore.error = 'Request content is empty';
                return;
            }

            tagsStore.tags = data.payload.map((tagDto) => ({
                id: tagDto.id,
                name: tagDto.name,
            }));
        },
    });
}

/**
 * Create a new tag and add it to the state
 * @param tag - Partial tag data (name only, ID generated by backend)
 */
export async function createTag(tag: Omit<Tag, 'id'>): Promise<void> {
    const tagsStore = useTagsStore();

    const payload: CreateTagRequest = { name: tag.name };

    await useApiInStore<TagDto>({
        store: tagsStore,
        apiCall: () => api.post('/tags', payload),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                tagsStore.error = 'Request content is empty';
                return;
            }

            tagsStore.tags.push({
                id: data.payload.id,
                name: data.payload.name,
            });
        },
    });
}

/**
 * Update an existing tag
 * @param tagId - The tag ID to update
 * @param tag - Partial tag data with fields to update
 */
export async function updateTag(tagId: number, tag: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const tagsStore = useTagsStore();

    const payload: UpdateTagRequest = { name: tag.name };

    await useApiInStore<TagDto>({
        store: tagsStore,
        apiCall: () => api.put(`/tags/${tagId}`, payload),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                tagsStore.error = 'Response content is empty';
                return;
            }

            const index = tagsStore.tags.findIndex((t) => t.id === tagId);
            if (index !== -1) {
                tagsStore.tags[index] = data.payload;
            }

            // Update tag reference in sheets list
            const sheetsStore = useSheetsStore();
            sheetsStore.sheetsList.forEach((sheet) => {
                sheet.tags = sheet.tags.map((t) =>
                    t.id === tagId ? { id: tagId, name: data.payload!.name } : t,
                );
            });

            // Update tag reference in detailed sheets
            Object.keys(sheetsStore.detailedSheets).forEach((key) => {
                const sheet = sheetsStore.detailedSheets[key];
                sheet.tags = sheet.tags.map((t) =>
                    t.id === tagId ? { id: tagId, name: tag.name ?? t.name } : t,
                );
            });
        },
    });
}

/**
 * Delete a tag from the state
 * @param tagId - The tag ID to delete
 */
export async function deleteTag(tagId: number): Promise<void> {
    const tagsStore = useTagsStore();

    await useApiInStore<void>({
        store: tagsStore,
        apiCall: () => api.delete(`/tags/${tagId}`),
        onSuccess: () => {
            tagsStore.tags = tagsStore.tags.filter((t) => t.id !== tagId);

            // Clear tag reference in sheets list
            const sheetsStore = useSheetsStore();
            sheetsStore.sheetsList.forEach((sheet) => {
                sheet.tags = sheet.tags.filter((tag) => tag.id !== tagId);
            });

            // Clear tag reference in detailed sheets
            Object.keys(sheetsStore.detailedSheets).forEach((key) => {
                const sheet = sheetsStore.detailedSheets[key];
                sheet.tags = sheet.tags.filter((tag) => tag.id !== tagId);
            });
        },
    });
}