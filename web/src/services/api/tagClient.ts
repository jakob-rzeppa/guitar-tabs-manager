import { useTagStore } from "@/stores/tagStore";
import api, { callApi } from "../api";
import type { CreateTagRequest, TagDto, UpdateTagRequest } from "@/types/dtos";
import type { Tag } from "@/types/types";
import { useSheetStore } from "@/stores/sheetStore";
import { toRef } from "vue";

/**
 * Fetch all tags
 * @param options.force - Force refetch even if data is already loaded
 */
export async function fetchAllTags(options: { force?: boolean } = {}): Promise<void> {
    const tagStore = useTagStore();
    // Skip if already loaded unless force is true
    if (!options.force && tagStore.tags.length > 0) return;

    await callApi<TagDto[]>({
        loadingRef: toRef(tagStore, 'loading'),
        errorRef: toRef(tagStore, 'error'),
        apiCall: () => api.get('/tags'),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                tagStore.error = 'Request content is empty';
                return;
            }

            tagStore.tags = data.payload.map((tagDto) => ({
                id: tagDto.id,
                name: tagDto.name,
            }));
        },
    });
}

/**
 * Create a new tag and add it to the state
 * @param tag - Partial tag data (name only, ID generated by backend)
 */
export async function createTag(tag: Omit<Tag, 'id'>): Promise<void> {
    const tagStore = useTagStore();

    const payload: CreateTagRequest = { name: tag.name };

    await callApi<TagDto>({
        loadingRef: toRef(tagStore, 'loading'),
        errorRef: toRef(tagStore, 'error'),
        apiCall: () => api.post('/tags', payload),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                tagStore.error = 'Request content is empty';
                return;
            }

            tagStore.tags.push({
                id: data.payload.id,
                name: data.payload.name,
            });
        },
    });
}

/**
 * Update an existing tag
 * @param tagId - The tag ID to update
 * @param tag - Partial tag data with fields to update
 */
export async function updateTag(tagId: number, tag: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const tagStore = useTagStore();

    const payload: UpdateTagRequest = { name: tag.name };

    await callApi<TagDto>({
        loadingRef: toRef(tagStore, 'loading'),
        errorRef: toRef(tagStore, 'error'),
        apiCall: () => api.put(`/tags/${tagId}`, payload),
        onSuccess: ({ data }) => {
            if (!data.payload) {
                tagStore.error = 'Response content is empty';
                return;
            }

            const index = tagStore.tags.findIndex((t) => t.id === tagId);
            if (index !== -1) {
                tagStore.tags[index] = data.payload;
            }

            // Update tag reference in sheets list
            const sheetStore = useSheetStore();
            sheetStore.sheetsList.forEach((sheet) => {
                sheet.tags = sheet.tags.map((t) =>
                    t.id === tagId ? { id: tagId, name: data.payload!.name } : t,
                );
            });

            // Update tag reference in detailed sheets
            Object.keys(sheetStore.detailedSheets).forEach((key) => {
                const sheet = sheetStore.detailedSheets[key];
                sheet.tags = sheet.tags.map((t) =>
                    t.id === tagId ? { id: tagId, name: tag.name ?? t.name } : t,
                );
            });
        },
    });
}

/**
 * Delete a tag from the state
 * @param tagId - The tag ID to delete
 */
export async function deleteTag(tagId: number): Promise<void> {
    const tagStore = useTagStore();

    await callApi<void>({
        loadingRef: toRef(tagStore, 'loading'),
        errorRef: toRef(tagStore, 'error'),
        apiCall: () => api.delete(`/tags/${tagId}`),
        onSuccess: () => {
            tagStore.tags = tagStore.tags.filter((t) => t.id !== tagId);

            // Clear tag reference in sheets list
            const sheetStore = useSheetStore();
            sheetStore.sheetsList.forEach((sheet) => {
                sheet.tags = sheet.tags.filter((tag) => tag.id !== tagId);
            });

            // Clear tag reference in detailed sheets
            Object.keys(sheetStore.detailedSheets).forEach((key) => {
                const sheet = sheetStore.detailedSheets[key];
                sheet.tags = sheet.tags.filter((tag) => tag.id !== tagId);
            });
        },
    });
}