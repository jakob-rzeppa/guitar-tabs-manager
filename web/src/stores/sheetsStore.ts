import { defineStore } from 'pinia';
import api, { useApiInStore } from '@/services/api.ts';
import type { Sheet, SheetListItem } from '@/types/types.ts';
import type { CreateSheetRequest, DeleteDto, SheetDto, SheetListItemDto } from '@/types/dtos';

interface SheetState {
    detailedSheets: Record<string, Sheet>;
    sheetsList: SheetListItem[];
    loading: boolean;
    error: string | null;
}

export const useSheetsStore = defineStore('sheets', {
    state: (): SheetState => ({
        detailedSheets: {},
        sheetsList: [],
        loading: false,
        error: null,
    }),

    actions: {
        /**
         * Fetch all sheets in condensed format (without content and capo)
         * @param options.force - Force refetch even if data is already loaded
         */
        async fetchAllSheets(options: { force?: boolean } = {}): Promise<void> {
            // Skip if already loaded unless force is true
            if (!options.force && this.sheetsList.length > 0) return;

            await useApiInStore<SheetListItemDto[]>({
                store: this,
                apiCall: () => api.get('/sheets'),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.sheetsList = data.content.map((sheet) => ({
                        id: sheet.id,
                        title: sheet.title,
                        artist: sheet.artist,
                        tags: sheet.tags,
                    }));
                },
            });
        },

        /**
         * Fetch a single sheet with full details (includes content and capo)
         * @param id - The sheet ID to fetch
         * @param options.force - Force refetch even if already cached
         */
        async fetchSheet(id: string, options: { force?: boolean } = {}): Promise<void> {
            // Skip if already cached unless force is true
            if (!options.force && this.detailedSheets[id]) return;

            await useApiInStore<SheetDto>({
                store: this,
                apiCall: () => api.get(`/sheets/${id}`),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.detailedSheets[id] = {
                        id: data.content.id,
                        title: data.content.title,
                        artist: data.content.artist,
                        tags: data.content.tags,
                        capo: data.content.capo,
                        sourceURL: data.content.source_url,
                        content: data.content.content,
                    };
                },
            });
        },

        /**
         * Create a new sheet and add it to the detailed cache
         * @param sheet - Sheet data without ID (generated by backend)
         */
        async createSheet(sheet: Omit<Sheet, 'id'>): Promise<void> {
            const payload: CreateSheetRequest = {
                title: sheet.title,
                content: sheet.content,
                capo: sheet.capo,
                source_url: sheet.sourceURL,
                artist_id: sheet.artist?.id,
                tag_ids: sheet.tags?.map((tag) => tag.id),
            };

            await useApiInStore<SheetDto>({
                store: this,
                apiCall: () => api.post('/sheets', payload),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.detailedSheets[data.content.id] = {
                        id: data.content.id,
                        title: data.content.title,
                        artist: data.content.artist,
                        tags: data.content.tags,
                        capo: data.content.capo,
                        sourceURL: data.content.source_url,
                        content: data.content.content,
                    };

                    // Add to sheetsList as well
                    this.sheetsList.push({
                        id: data.content.id,
                        title: data.content.title,
                        artist: data.content.artist,
                        tags: data.content.tags,
                    });
                },
            });
        },

        /**
         * Update a sheet with only the changed fields
         * @param id - The sheet ID to update
         * @param fieldsToUpdate - Partial sheet data with fields to update
         */
        async updateSheet(id: string, fieldsToUpdate: Partial<Omit<Sheet, 'id'>>): Promise<void> {
            const currentSheet = this.detailedSheets[id];

            const payload: {
                title?: string;
                content?: string;
                capo?: number;
                source_url?: string;
                artist_id?: number;
                tag_ids?: number[];
            } = {};

            // Compare primitive fields
            if (
                fieldsToUpdate.title !== undefined &&
                fieldsToUpdate.title !== currentSheet?.title
            ) {
                payload.title = fieldsToUpdate.title;
            }
            if (
                fieldsToUpdate.content !== undefined &&
                fieldsToUpdate.content !== currentSheet?.content
            ) {
                payload.content = fieldsToUpdate.content;
            }
            if (fieldsToUpdate.capo !== undefined && fieldsToUpdate.capo !== currentSheet?.capo) {
                payload.capo = fieldsToUpdate.capo;
            }
            if (
                fieldsToUpdate.sourceURL !== undefined &&
                fieldsToUpdate.sourceURL !== currentSheet?.sourceURL
            ) {
                payload.source_url = fieldsToUpdate.sourceURL;
            }

            // Compare complex fields using JSON serialization
            if (
                fieldsToUpdate.artist !== undefined &&
                JSON.stringify(fieldsToUpdate.artist) !== JSON.stringify(currentSheet?.artist)
            ) {
                payload.artist_id = fieldsToUpdate.artist?.id;
            }
            if (
                fieldsToUpdate.tags !== undefined &&
                JSON.stringify(fieldsToUpdate.tags) !== JSON.stringify(currentSheet?.tags)
            ) {
                payload.tag_ids = fieldsToUpdate.tags?.map((tag) => tag.id);
            }

            // Don't send request if nothing changed
            if (Object.keys(payload).length === 0) {
                return;
            }

            await useApiInStore<SheetDto>({
                store: this,
                apiCall: () => api.put(`/sheets/${id}`, payload),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.detailedSheets[id] = {
                        id: data.content.id,
                        title: data.content.title,
                        artist: data.content.artist,
                        tags: data.content.tags,
                        capo: data.content.capo,
                        sourceURL: data.content.source_url,
                        content: data.content.content,
                    };

                    // Also update sheetsList entry
                    const index = this.sheetsList.findIndex((sheet) => sheet.id === Number(id));
                    if (index !== -1) {
                        this.sheetsList[index] = {
                            id: data.content.id,
                            title: data.content.title,
                            artist: data.content.artist,
                            tags: data.content.tags,
                        };
                    }
                },
            });
        },

        /**
         * Delete a sheet and remove it from the cache
         * @param id - The sheet ID to delete
         */
        async deleteSheet(id: string): Promise<void> {
            await useApiInStore<DeleteDto>({
                store: this,
                apiCall: () => api.delete(`/sheets/${id}`),
                onSuccess: () => {
                    delete this.detailedSheets[id];

                    // Also remove from sheetsList
                    const index = this.sheetsList.findIndex((sheet) => sheet.id === Number(id));
                    if (index !== -1) {
                        this.sheetsList.splice(index, 1);
                    }
                },
            });
        },
    },
});
