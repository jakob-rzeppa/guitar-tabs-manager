import { defineStore } from 'pinia';
import api, { useApiInStore } from '@/services/api.ts';
import type { Tab, TabListItem } from '@/types/types.ts';

interface TabState {
    detailedTabs: Record<string, Tab>;
    tabsList: TabListItem[];
    loading: boolean;
    error: string | null;
}

export const useTabsStore = defineStore('tabs', {
    state: (): TabState => ({
        detailedTabs: {},
        tabsList: [],
        loading: false,
        error: null,
    }),

    actions: {
        /**
         * Fetch all tabs in condensed format (without content and capo)
         * @param options.force - Force refetch even if data is already loaded
         */
        async fetchAllTabs(options: { force?: boolean } = {}): Promise<void> {
            // Skip if already loaded unless force is true
            if (!options.force && this.tabsList.length > 0) return;

            await useApiInStore<TabListItem[]>({
                store: this,
                apiCall: () => api.get('/tabs'),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.tabsList = data.content;
                },
            });
        },

        /**
         * Fetch a single tab with full details (includes content and capo)
         * @param id - The tab ID to fetch
         * @param options.force - Force refetch even if already cached
         */
        async fetchTab(id: string, options: { force?: boolean } = {}): Promise<void> {
            // Skip if already cached unless force is true
            if (!options.force && this.detailedTabs[id]) return;

            await useApiInStore<Tab>({
                store: this,
                apiCall: () => api.get(`/tabs/${id}`),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.detailedTabs[id] = data.content;
                },
            });
        },

        /**
         * Create a new tab and add it to the detailed cache
         * @param tab - Tab data without ID (generated by backend)
         */
        async createTab(tab: Omit<Tab, 'id'>): Promise<void> {
            const payload = {
                title: tab.title,
                content: tab.content,
                capo: tab.capo,
                source_url: tab.sourceURL,
                artist_id: tab.artist?.id,
                tag_ids: tab.tags?.map((tag) => tag.id),
            };

            await useApiInStore<Tab>({
                store: this,
                apiCall: () => api.post('/tabs', payload),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.detailedTabs[data.content.id] = data.content;

                    // Add to tabsList as well
                    const { id, title, artist, tags } = data.content;
                    this.tabsList.push({ id, title, artist, tags });
                },
            });
        },

        /**
         * Update a tab with only the changed fields
         * @param id - The tab ID to update
         * @param fieldsToUpdate - Partial tab data with fields to update
         */
        async updateTab(id: string, fieldsToUpdate: Partial<Omit<Tab, 'id'>>): Promise<void> {
            const currentTab = this.detailedTabs[id];

            const payload: {
                title?: string;
                content?: string;
                capo?: number;
                source_url?: string;
                artist_id?: number;
                tag_ids?: number[];
            } = {};

            // Compare primitive fields
            if (fieldsToUpdate.title !== undefined && fieldsToUpdate.title !== currentTab?.title) {
                payload.title = fieldsToUpdate.title;
            }
            if (
                fieldsToUpdate.content !== undefined &&
                fieldsToUpdate.content !== currentTab?.content
            ) {
                payload.content = fieldsToUpdate.content;
            }
            if (fieldsToUpdate.capo !== undefined && fieldsToUpdate.capo !== currentTab?.capo) {
                payload.capo = fieldsToUpdate.capo;
            }
            if (
                fieldsToUpdate.sourceURL !== undefined &&
                fieldsToUpdate.sourceURL !== currentTab?.sourceURL
            ) {
                payload.source_url = fieldsToUpdate.sourceURL;
            }

            // Compare complex fields using JSON serialization
            if (
                fieldsToUpdate.artist !== undefined &&
                JSON.stringify(fieldsToUpdate.artist) !== JSON.stringify(currentTab?.artist)
            ) {
                payload.artist_id = fieldsToUpdate.artist?.id;
            }
            if (
                fieldsToUpdate.tags !== undefined &&
                JSON.stringify(fieldsToUpdate.tags) !== JSON.stringify(currentTab?.tags)
            ) {
                payload.tag_ids = fieldsToUpdate.tags?.map((tag) => tag.id);
            }

            // Don't send request if nothing changed
            if (Object.keys(payload).length === 0) {
                return;
            }

            await useApiInStore<Tab>({
                store: this,
                apiCall: () => api.put(`/tabs/${id}`, payload),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.detailedTabs[id] = data.content;

                    // Also update tabsList entry
                    const index = this.tabsList.findIndex((tab) => tab.id === Number(id));
                    if (index !== -1) {
                        this.tabsList[index] = data.content;
                    }
                },
            });
        },

        /**
         * Delete a tab and remove it from the cache
         * @param id - The tab ID to delete
         */
        async deleteTab(id: string): Promise<void> {
            await useApiInStore<void>({
                store: this,
                apiCall: () => api.delete(`/tabs/${id}`),
                onSuccess: () => {
                    delete this.detailedTabs[id];

                    // Also remove from tabsList
                    const index = this.tabsList.findIndex((tab) => tab.id === Number(id));
                    if (index !== -1) {
                        this.tabsList.splice(index, 1);
                    }
                },
            });
        },
    },
});
