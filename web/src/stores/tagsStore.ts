import api, { useApiInStore } from '@/services/api';
import type { CreateTagRequest, TagDto, UpdateTagRequest } from '@/types/dtos';
import type { Tag } from '@/types/types';
import { defineStore } from 'pinia';
import { useTabsStore } from './tabsStore';

interface State {
    tags: Tag[];
    loading: boolean;
    error: string | null;
}

export const useTagsStore = defineStore('tags', {
    state: (): State => ({
        tags: [],
        loading: false,
        error: null,
    }),
    actions: {
        /**
         * Fetch all tags
         * @param options.force - Force refetch even if data is already loaded
         */
        async fetchAllTags(options: { force?: boolean } = {}): Promise<void> {
            // Skip if already loaded unless force is true
            if (!options.force && this.tags.length > 0) return;

            await useApiInStore<TagDto[]>({
                store: this,
                apiCall: () => api.get('/tags'),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.tags = data.content.map((tagDto) => ({
                        id: tagDto.id,
                        name: tagDto.name,
                    }));
                },
            });
        },

        /**
         * Create a new tag and add it to the state
         * @param tag - Partial tag data (name only, ID generated by backend)
         */
        async createTag(tag: Omit<Tag, 'id'>): Promise<void> {
            const payload: CreateTagRequest = { name: tag.name };

            await useApiInStore<TagDto>({
                store: this,
                apiCall: () => api.post('/tags', payload),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.tags.push({
                        id: data.content.id,
                        name: data.content.name,
                    });
                },
            });
        },

        /**
         * Update an existing tag
         * @param tagId - The tag ID to update
         * @param tag - Partial tag data with fields to update
         */
        async updateTag(tagId: number, tag: Partial<Omit<Tag, 'id'>>): Promise<void> {
            const payload: UpdateTagRequest = { name: tag.name };

            await useApiInStore<TagDto>({
                store: this,
                apiCall: () => api.put(`/tags/${tagId}`, payload),
                onSuccess: ({ data }) => {
                    if (!data.content) {
                        this.error = 'Response content is empty';
                        return;
                    }

                    const index = this.tags.findIndex((t) => t.id === tagId);
                    if (index !== -1) {
                        this.tags[index] = data.content;
                    }

                    // Update tag reference in tabs list
                    const tabsStore = useTabsStore();
                    tabsStore.tabsList.forEach((tab) => {
                        tab.tags = tab.tags.map((t) =>
                            t.id === tagId ? { id: tagId, name: data.content!.name } : t
                        );
                    });

                    // Update tag reference in detailed tabs
                    Object.keys(tabsStore.detailedTabs).forEach((key) => {
                        const tab = tabsStore.detailedTabs[key];
                        tab.tags = tab.tags.map((t) =>
                            t.id === tagId ? { id: tagId, name: tag.name ?? t.name } : t
                        );
                    });
                },
            });
        },

        /**
         * Delete a tag from the state
         * @param tagId - The tag ID to delete
         */
        async deleteTag(tagId: number): Promise<void> {
            await useApiInStore<void>({
                store: this,
                apiCall: () => api.delete(`/tags/${tagId}`),
                onSuccess: () => {
                    this.tags = this.tags.filter((t) => t.id !== tagId);

                    // Clear tag reference in tabs list
                    const tabsStore = useTabsStore();
                    tabsStore.tabsList.forEach((tab) => {
                        tab.tags = tab.tags.filter(tag => tag.id !== tagId);
                    });

                    // Clear tag reference in detailed tabs
                    Object.keys(tabsStore.detailedTabs).forEach((key) => {
                        const tab = tabsStore.detailedTabs[key];
                        tab.tags = tab.tags.filter(tag => tag.id !== tagId);
                    });
                },
            });
        }
    },
});
