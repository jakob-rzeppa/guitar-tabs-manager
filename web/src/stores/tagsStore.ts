import api, { useApiInStore } from '@/services/api';
import type { CreateTagRequest, TagDto, UpdateTagRequest } from '@/types/dtos';
import type { Tag } from '@/types/types';
import { defineStore } from 'pinia';
import { useSheetsStore } from './sheetsStore';

interface State {
    tags: Tag[];
    loading: boolean;
    error: string | null;
}

export const useTagsStore = defineStore('tags', {
    state: (): State => ({
        tags: [],
        loading: false,
        error: null,
    }),
    actions: {
        /**
         * Fetch all tags
         * @param options.force - Force refetch even if data is already loaded
         */
        async fetchAllTags(options: { force?: boolean } = {}): Promise<void> {
            // Skip if already loaded unless force is true
            if (!options.force && this.tags.length > 0) return;

            await useApiInStore<TagDto[]>({
                store: this,
                apiCall: () => api.get('/tags'),
                onSuccess: ({ data }) => {
                    if (!data.payload) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.tags = data.payload.map((tagDto) => ({
                        id: tagDto.id,
                        name: tagDto.name,
                    }));
                },
            });
        },

        /**
         * Create a new tag and add it to the state
         * @param tag - Partial tag data (name only, ID generated by backend)
         */
        async createTag(tag: Omit<Tag, 'id'>): Promise<void> {
            const payload: CreateTagRequest = { name: tag.name };

            await useApiInStore<TagDto>({
                store: this,
                apiCall: () => api.post('/tags', payload),
                onSuccess: ({ data }) => {
                    if (!data.payload) {
                        this.error = 'Request content is empty';
                        return;
                    }

                    this.tags.push({
                        id: data.payload.id,
                        name: data.payload.name,
                    });
                },
            });
        },

        /**
         * Update an existing tag
         * @param tagId - The tag ID to update
         * @param tag - Partial tag data with fields to update
         */
        async updateTag(tagId: number, tag: Partial<Omit<Tag, 'id'>>): Promise<void> {
            const payload: UpdateTagRequest = { name: tag.name };

            await useApiInStore<TagDto>({
                store: this,
                apiCall: () => api.put(`/tags/${tagId}`, payload),
                onSuccess: ({ data }) => {
                    if (!data.payload) {
                        this.error = 'Response content is empty';
                        return;
                    }

                    const index = this.tags.findIndex((t) => t.id === tagId);
                    if (index !== -1) {
                        this.tags[index] = data.payload;
                    }

                    // Update tag reference in sheets list
                    const sheetsStore = useSheetsStore();
                    sheetsStore.sheetsList.forEach((sheet) => {
                        sheet.tags = sheet.tags.map((t) =>
                            t.id === tagId ? { id: tagId, name: data.payload!.name } : t,
                        );
                    });

                    // Update tag reference in detailed sheets
                    Object.keys(sheetsStore.detailedSheets).forEach((key) => {
                        const sheet = sheetsStore.detailedSheets[key];
                        sheet.tags = sheet.tags.map((t) =>
                            t.id === tagId ? { id: tagId, name: tag.name ?? t.name } : t,
                        );
                    });
                },
            });
        },

        /**
         * Delete a tag from the state
         * @param tagId - The tag ID to delete
         */
        async deleteTag(tagId: number): Promise<void> {
            await useApiInStore<void>({
                store: this,
                apiCall: () => api.delete(`/tags/${tagId}`),
                onSuccess: () => {
                    this.tags = this.tags.filter((t) => t.id !== tagId);

                    // Clear tag reference in sheets list
                    const sheetsStore = useSheetsStore();
                    sheetsStore.sheetsList.forEach((sheet) => {
                        sheet.tags = sheet.tags.filter((tag) => tag.id !== tagId);
                    });

                    // Clear tag reference in detailed sheets
                    Object.keys(sheetsStore.detailedSheets).forEach((key) => {
                        const sheet = sheetsStore.detailedSheets[key];
                        sheet.tags = sheet.tags.filter((tag) => tag.id !== tagId);
                    });
                },
            });
        },
    },
});
